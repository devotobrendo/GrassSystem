// Copyright (c) 2026 Brendo Otavio Carvalho de Matos. All rights reserved.

#pragma kernel CSMain

struct GrassInput
{
    float3 position;
    float3 normal;
    float2 widthHeight;
    float3 color;
    float patternMask;
};

struct GrassOutput
{
    float3 position;
    float3 normal;
    float2 widthHeight;
    float3 color;
    float patternMask;
    float distanceScale;
};

StructuredBuffer<GrassInput> _SourceBuffer;
AppendStructuredBuffer<GrassOutput> _VisibleBuffer;
RWStructuredBuffer<uint> _IndirectArgsBuffer;

float4x4 _ViewProjectionMatrix;
float3 _CameraPosition;
float4 _FrustumPlanes[6];

float _MinFadeDistance;
float _MaxDrawDistance;
float _MinHeight;
float _MaxHeight;
float _MinWidth;
float _MaxWidth;

float4 _Interactors[16];
int _InteractorCount;
float _InteractorStrength;

float _Time;
float _WindSpeed;
float _WindStrength;
float _WindFrequency;

uint _InstanceCount;

bool IsInFrustum(float3 position, float radius)
{
    [unroll]
    for (int i = 0; i < 6; i++)
    {
        float dist = dot(_FrustumPlanes[i].xyz, position) + _FrustumPlanes[i].w;
        if (dist < -radius)
            return false;
    }
    return true;
}

float CalculateDistanceScale(float3 position)
{
    float dist = distance(_CameraPosition, position);
    
    if (dist > _MaxDrawDistance)
        return 0.0;
    
    if (dist < _MinFadeDistance)
        return 1.0;
    
    return 1.0 - saturate((dist - _MinFadeDistance) / (_MaxDrawDistance - _MinFadeDistance));
}

float3 CalculateInteractionOffset(float3 position)
{
    float3 totalOffset = float3(0, 0, 0);
    
    [loop]
    for (int i = 0; i < _InteractorCount; i++)
    {
        float3 interactorPos = _Interactors[i].xyz;
        float radius = _Interactors[i].w;
        
        if (radius <= 0)
            continue;
        
        float3 toGrass = position - interactorPos;
        float dist = length(toGrass.xz);
        
        if (dist < radius && dist > 0.001)
        {
            float influence = 1.0 - saturate(dist / radius);
            influence = influence * influence;
            
            float3 pushDir = normalize(float3(toGrass.x, 0, toGrass.z));
            totalOffset += pushDir * influence * _InteractorStrength;
        }
    }
    
    return totalOffset;
}

[numthreads(128, 1, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _InstanceCount)
        return;
    
    GrassInput input = _SourceBuffer[id.x];
    
    float bladeRadius = max(input.widthHeight.x, input.widthHeight.y) * 0.5;
    if (!IsInFrustum(input.position, bladeRadius))
        return;
    
    float distScale = CalculateDistanceScale(input.position);
    if (distScale <= 0.01)
        return;
    
    GrassOutput output;
    output.position = input.position;
    output.normal = input.normal;
    output.widthHeight = input.widthHeight;
    output.color = input.color;
    output.patternMask = input.patternMask;
    output.distanceScale = distScale;
    
    _VisibleBuffer.Append(output);
    InterlockedAdd(_IndirectArgsBuffer[1], 1);
}
